'use babel';
/* @flow */

/**
 * Construct this object to enable Hyperclick in a text editor.
 * Call `dispose` to disable the feature.
 */
class HyperclickForTextEditor {
  constructor(
      textEditor: TextEditor,
      getSuggestion: (textEditor: Editor, position: Point) => Promise<?HyperclickSuggestion>) {
    this._textEditor = textEditor;
    this._textEditorView = atom.views.getView(textEditor);

    this._getSuggestion = getSuggestion;

    this._lastMouseEvent = null;
    // We store the original promise that we use to retrieve the last suggestion
    // so callers can also await it to know when it's available.
    this._lastSuggestionPromise = null;
    // We store the last suggestion since we must await it immediately anyway.
    this._lastSuggestion = null;
    this._navigationMarkers = null;

    // We deliberately use a DOM node that's deeper than `scrollViewNode` so
    // we can handle <meta-click> and still prevent the text editor from adding
    // another cursor.
    this._mouseEventHandlerEl = this._textEditorView.component.scrollViewNode.querySelector('.lines');
    this._onMouseMove = this._onMouseMove.bind(this);
    this._mouseEventHandlerEl.addEventListener('mousemove', this._onMouseMove);
    this._onMouseDown = this._onMouseDown.bind(this);
    this._mouseEventHandlerEl.addEventListener('mousedown', this._onMouseDown);

    this._onKeyDown = this._onKeyDown.bind(this);
    this._textEditorView.addEventListener('keydown', this._onKeyDown);
    this._onKeyUp = this._onKeyUp.bind(this);
    this._textEditorView.addEventListener('keyup', this._onKeyUp);
  }

  _onMouseMove(event: MouseEvent): Promise {
    // We save the last `MouseEvent` so the user can trigger Hyperclick by
    // pressing the key without moving the mouse again. We only save the
    // relevant properties to prevent retaining a reference to the event.
    this._lastMouseEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
    };

    if (this._isHyperclickEvent(event)) {
      this._setSuggestionForLastMouseEvent();
    } else {
      this._clearSuggestion();
    }
  }

  _onMouseDown(event: MouseEvent): void {
    if (!this._isHyperclickEvent(event)) {
      return;
    }

    if (this._lastSuggestion) {
      this._lastSuggestion.callback();
    }

    this._clearSuggestion();
    // Prevent the <meta-click> event from adding another cursor.
    event.stopPropagation();
  }

  _onKeyDown(event: KeyboardEvent): void {
    // Show the suggestion at the last known mouse position.
    if (this._isHyperclickEvent(event)) {
      this._setSuggestionForLastMouseEvent();
    }
  }

  _onKeyUp(event: KeyboardEvent): void {
    if (!this._isHyperclickEvent(event)) {
      this._clearSuggestion();
    }
  }

  /**
   * Returns a `Promise` that's resolved when the latest suggestion's available.
   */
  getSuggestion(): Promise<HyperclickSuggestion> {
    return this._lastSuggestionPromise || Promise.resolve(null);
  }

  async _setSuggestionForLastMouseEvent(): void {
    if (!this._lastMouseEvent) {
      return;
    }

    var position = this._textEditorView.component.screenPositionForMouseEvent(this._lastMouseEvent);

    if (this._lastSuggestion) {
      var {range} = this._lastSuggestion;
      var isInLastRanges = (Array.isArray(range) && range.some(r => r.containsPoint(position)));
      if (isInLastRanges || (!Array.isArray(range) && range.containsPoint(position))) {
        return;
      }
    }

    this._lastSuggestionPromise = this._getSuggestion(this._textEditor, position);
    this._lastSuggestion = await this._lastSuggestionPromise;
    if (this._lastSuggestion) {
      this._updateNavigationMarkers(this._lastSuggestion.range);
    }
  }

  _clearSuggestion(): void {
    this._lastSuggestionPromise = null;
    this._lastSuggestion = null;
    this._updateNavigationMarkers(null);
  }

  /**
   * Add markers for the given range(s), or clears them if `ranges` is null.
   */
  _updateNavigationMarkers(range: ?Range | ?Array<Range>): void {
    if (this._navigationMarkers) {
      this._navigationMarkers.forEach(marker => marker.destroy());
      this._navigationMarkers = null;
    }

    if (range) {
      var ranges = Array.isArray(range) ? range : [range];

      this._navigationMarkers = ranges.map(range => {
        var marker = this._textEditor.markBufferRange(range, {invalidate: 'never'});
        this._textEditor.decorateMarker(
            marker,
            {type: 'highlight', class: 'hyperclick'});
        return marker;
      });
      this._textEditorView.classList.add('hyperclick');
    } else {
      this._textEditorView.classList.remove('hyperclick');
    }
  }

  /**
   * Returns whether an event should be handled by hyperclick or not.
   */
  _isHyperclickEvent(event: KeyboardEvent | MouseEvent): boolean {
    // If the user is pressing either the meta key or the alt key.
    return event.metaKey !== event.altKey;
  }

  dispose() {
    this._mouseEventHandlerEl.removeEventListener('mousemove', this._onMouseMove);
    this._mouseEventHandlerEl.removeEventListener('mousedown', this._onMouseDown);
    this._textEditorView.removeEventListener('keydown', this._onKeyDown);
    this._textEditorView.removeEventListener('keyup', this._onKeyUp);
  }
}

module.exports = HyperclickForTextEditor;
